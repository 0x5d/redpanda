/*
 * Copyright 2020 Vectorized, Inc.
 *
 * Use of this software is governed by the Business Source License
 * included in the file licenses/BSL.md
 *
 * As of the Change Date specified in that file, in accordance with
 * the Business Source License, use of this software will be governed
 * by the Apache License, Version 2.0
 */
#pragma once
#include "cluster/types.h"
#include "model/metadata.h"

namespace cluster {
class allocation_node {
public:
    static constexpr const uint32_t core0_extra_weight = 2;
    // TODO make configurable
    static constexpr const uint32_t max_allocations_per_core = 7000;

    allocation_node(
      model::node_id id,
      uint32_t cpus,
      std::unordered_map<ss::sstring, ss::sstring> labels)
      : _id(id)
      , _weights(cpus)
      , _max_capacity((cpus * max_allocations_per_core) - core0_extra_weight)
      , _machine_labels(std::move(labels))
      , _decommissioned(false) {
        // add extra weights to core 0
        _weights[0] = core0_extra_weight;
        _partition_capacity = _max_capacity;
    }

    allocation_node(allocation_node&& o) noexcept
      : _id(o._id)
      , _weights(std::move(o._weights))
      , _max_capacity(o._max_capacity)
      , _partition_capacity(o._partition_capacity)
      , _machine_labels(std::move(o._machine_labels))
      , _decommissioned(o._decommissioned) {
        _hook.swap_nodes(o._hook);
    }

    allocation_node& operator=(allocation_node&&) = delete;
    allocation_node(const allocation_node&) = delete;
    allocation_node& operator=(const allocation_node&) = delete;

    uint32_t cpus() const { return _weights.size(); }
    model::node_id id() const { return _id; }
    uint32_t partition_capacity() const { return _partition_capacity; }

    void decommission() { _decommissioned = true; }
    void recommission() { _decommissioned = false; }
    bool is_decommissioned() const { return _decommissioned; }
    bool empty() const { return _partition_capacity == _max_capacity; }

private:
    friend partition_allocator;

    bool is_full() const {
        for (uint32_t w : _weights) {
            if (w != max_allocations_per_core) {
                return false;
            }
        }
        return true;
    }
    uint32_t allocate() {
        auto it = std::min_element(_weights.begin(), _weights.end());
        (*it)++; // increment the weights
        _partition_capacity--;
        return std::distance(_weights.begin(), it);
    }
    void deallocate(uint32_t core) {
        vassert(
          core < _weights.size(),
          "Tried to deallocate a non-existing core:{} - {}",
          core,
          *this);
        _partition_capacity++;
        _weights[core]--;
    }
    void allocate(uint32_t core) {
        vassert(
          core < _weights.size(),
          "Tried to allocate a non-existing core:{} - {}",
          core,
          *this);
        _weights[core]++;
        _partition_capacity--;
    }
    const std::unordered_map<ss::sstring, ss::sstring>& machine_labels() const {
        return _machine_labels;
    }

    model::node_id _id;
    /// each index is a CPU. A weight is roughly the number of assigments
    std::vector<uint32_t> _weights;
    const uint32_t _max_capacity;
    uint32_t _partition_capacity{0};
    /// generated by `rpk` usually in /etc/redpanda/machine_labels.json
    std::unordered_map<ss::sstring, ss::sstring> _machine_labels;
    bool _decommissioned;
    // for partition_allocator
    safe_intrusive_list_hook _hook;

    friend std::ostream& operator<<(std::ostream&, const allocation_node&);
};
} // namespace cluster
